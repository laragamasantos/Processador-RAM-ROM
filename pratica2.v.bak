//Lara Gama Santos & Lucas Santos Rodrigues
//ParteA

//`include "ram.v"
//`include "rom.v"

module pratica2 (DIN, Resetn, Clock, Run, Done);
	input [15:0] DIN;
	input Resetn, Clock, Run;
	output Done;
	
	wire [15:0] r0, r1, r2, r3, r4, r5, r6, r7, a, g, IR, result;
	wire [2:0] III, rX, rY;
	wire Imm;
	wire [7:0] R_in;
	wire [4:0] outCounter;
	
	reg A_in, rX_in, G_in, IR_in, aux_Done;
	reg ALU_op; //ALU_op: add->00, sub->01, and->10
	reg [15:0] BusWires;
	reg [2:0] Tstep_D, Tstep_Q;
	reg [3:0] Select;

	assign III = IR[15:13];
	assign Imm = IR[12];
	assign rX = IR[11:9];
	assign rY = IR[2:0];
	assign Done = aux_Done;
	
	dec3to8 decX (rX_in, rX, R_in); // produce r0 - r7 register enables
	//count counter (Resetn, Clock, outCounter);
	//ram memDados ();
	//rom memInst (outCounter, Clock, DIN);
	
	parameter T0 = 3'b000, T1 = 3'b001, T2 = 3'b010, T3 = 3'b011;
	
	initial begin
		Tstep_D = T0;
		Tstep_Q = T0;
		IR_in = 0;
		A_in = 0;
		G_in = 0;
		aux_Done = 0;
	end
	
	// Control FSM state table
	always @(Tstep_Q, Run, Done)
		case (Tstep_Q)
			T0: // data is loaded into IR in this time step
				if (~Run) Tstep_D = T0;
				else Tstep_D = T1;
			T1: begin
				if (~Done) Tstep_D = T2;
				else Tstep_D = T0;
			end
			T2: begin
				if (~Done) Tstep_D = T3;
				else Tstep_D = T0;
			end
			T3: begin
				if (~Done) Tstep_D = T0;
				else Tstep_D = T0;
			end
	endcase
		
	parameter mv = 3'b000, mvt = 3'b001, add = 3'b010, sub = 3'b011;
	// selectors for the BusWires multiplexer
	parameter R0 = 4'b0000, R1 = 4'b0001, R2 = 4'b0010,
	R3 = 4'b0011, R4 = 4'b0100, R5 = 4'b0101, R6 = 4'b0110, R7 = 4'b0111, G = 4'b1000,
	IR8_IR8_0 /* signed-extended immediate data */ = 4'b1001,
	IR7_0_0 /* immediate data << 8 */ = 4'b1010;

	// control FSM outputs
	always @(*) begin
		rX_in = 1'b0; aux_Done = 1'b0; A_in = 1'b0; G_in = 1'b0; //. . .  default values for variables
		case (Tstep_Q)
		
			T0: begin// store DIN into IR
				IR_in = 1'b1;
			end
			T1: begin// define signals in time step T3
				case (III)
					mv: begin
						if (!Imm) Select = rY; // mv rX, rY
						else Select = IR8_IR8_0; // mv rX, #D
						rX_in = 1'b1; // enable rX
						aux_Done = 1'b1;
					end
					mvt: begin
						Select = IR7_0_0; // mvt rX, #D
						rX_in = 1'b1; // enable rX
						aux_Done = 1'b1;
					end
					add: begin
						Select = rX;
						A_in = 1'b1;
					end
					sub: begin
						Select = rX;
						A_in = 1'b1;
					end
					default: ;
				endcase
			end
			T2: begin// define signals in time step T4
				case (III)
				add: begin
					if (!Imm) Select = rY; 
					else Select = IR8_IR8_0;
					ALU_op = 1'b0;
					G_in = 1'b1;
				end
				sub: begin
					if (!Imm) Select = rY; 
					else Select = IR8_IR8_0; 
					ALU_op = 1'b1;
					G_in = 1'b1;
				end
				default: ;
				endcase
			end
			T3: begin// define signals in time step T5
				case (III)
				add: begin
					Select = G;
					rX_in = 1'b1; // enable rX
					aux_Done = 1'b1;
				end
				sub: begin
					Select = G;
					rX_in = 1'b1; // enable rX
					aux_Done = 1'b1;
				end
				default: ;
				endcase
			end
		endcase
	end

	// Control FSM flip-flops
	always @(posedge Clock, negedge Resetn)
		if (!Resetn)
			Tstep_Q = T0;
		else
			Tstep_Q = Tstep_D;
		
	regn reg_0 (BusWires, Resetn, R_in[0], Clock, r0);
	regn reg_1 (BusWires, Resetn, R_in[1], Clock, r1);
	regn reg_2 (BusWires, Resetn, R_in[2], Clock, r2);
	regn reg_3 (BusWires, Resetn, R_in[3], Clock, r3);
	regn reg_4 (BusWires, Resetn, R_in[4], Clock, r4);
	regn reg_5 (BusWires, Resetn, R_in[5], Clock, r5);
	regn reg_6 (BusWires, Resetn, R_in[6], Clock, r6);
	regn reg_7 (BusWires, Resetn, R_in[7], Clock, r7);
	regn reg_G (result,   Resetn, G_in,    Clock, g );
	regn reg_A (BusWires, Resetn, A_in,    Clock, a );
	regn reg_IR(DIN,      Resetn, IR_in,   Clock, IR);

	ULAn ula (a, BusWires, ALU_op, result);
	//. . . instantiate other registers and the adder/subtracter unit

	// define the internal processor bus
	always @(*) begin
		case (Select)
			R0: BusWires = r0;
			R1: BusWires = r1;
			R2: BusWires = r2;
			R3: BusWires = r3;
			R4: BusWires = r4;
			R5: BusWires = r5;
			R6: BusWires = r6;
			R7: BusWires = r7;
			G: BusWires = g;
			IR8_IR8_0: BusWires = {{7{IR[8]}}, IR[8:0]};
			IR7_0_0: BusWires = {IR[7:0], 8'b00000000};
			default: BusWires = 16'bxxxxxxxxxxxxxxxx;
		endcase
	end
endmodule
	
module dec3to8(E, W, Y);
	input E; // enable
	input [2:0] W;
	output [7:0] Y;
	reg [7:0] Y;
	
	always @(*) begin
		if (E == 0)
			Y = 8'b00000000;
	else
		case (W)
			3'b000: Y = 8'b00000001;
			3'b001: Y = 8'b00000010;
			3'b010: Y = 8'b00000100;
			3'b011: Y = 8'b00001000;
			3'b100: Y = 8'b00010000;
			3'b101: Y = 8'b00100000;
			3'b110: Y = 8'b01000000;
			3'b111: Y = 8'b10000000;
		endcase
	end
endmodule

module regn (BusWires, Resetn, R_in, Clock, dado);
	input [15:0] BusWires;
	input Resetn, R_in, Clock;
	output reg [15:0] dado;

	// Escrita
	always @(posedge Clock, negedge Resetn) begin
		if(!Resetn) begin
			dado = 16'bx;
		end
		else if(R_in) begin
			dado = BusWires;
		end
	end
endmodule

module ULAn (in_1, in_2, OPcode, result);
	input [15:0] in_1, in_2;
	input  OPcode;
	output reg [15:0] result;
	
	always@(*) begin
		if(OPcode == 1'b0) //add
			result = (in_1 + in_2);
		if(OPcode == 1'b1)// sub
			result = (in_1 - in_2);
		/*else if (OPcode == 2'b10) begin // and
			if (in_1 and in_2) begin
				result = 16'b0000000000000001;
			end
			else begin
				result = 16'b0000000000000000;
			end
			end*/
	end
endmodule

module count (Resetn, Clock, Q);
	input Resetn, Clock;
	output reg [4:0] Q;
	
	always @ (posedge Clock, negedge Resetn)
		if (Resetn == 0)
			Q <= 5'b00000;
		else
			Q <= Q + 1'b1;
endmodule
